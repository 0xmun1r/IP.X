# ip_x/cli.py (Full code with new additions)

import argparse
import sys
import requests
import json
import dns.resolver
import dns.reversename # For reverse DNS lookups
import shodan
import censys.search
import socket
import ipaddress
import re # For regex, useful for parsing headers

# --- Configuration ---
PUBLIC_DNS_RESOLVERS = [
    '8.8.8.8',  # Google
    '1.1.1.1',  # Cloudflare
    '9.9.9.9',  # Quad9
    '208.67.222.222', # OpenDNS
]

CRT_SH_URL = "https://crt.sh/?q=%25.{domain}&output=json"

# Common HTTP/S ports for active scanning
COMMON_WEB_PORTS = [80, 443, 8080, 8443]

# Known WAF/CDN signatures (headers, server banners, cookies etc.) - (unchanged, but can be expanded further)
WAF_SIGNATURES = {
    'cloudflare': {
        'headers': ['Server: cloudflare', 'CF-RAY', 'cf-request-id', 'Cloudflare-CDN-ID', 'Accept-Encoding: gzip'],
        'cookies': ['__cfduid', '__cf_bm'],
        'html_keywords': ['cloudflare-nginx', 'DDoS protection by Cloudflare']
    },
    'incapsula': {
        'headers': ['X-CDN: Incapsula', 'X-Iinfo', 'Incapsula-debug', 'X-WAF-Proxy'],
        'cookies': ['incap_ses_', 'visid_incap_'],
        'html_keywords': ['Incapsula incident ID']
    },
    'sucuri': {
        'headers': ['X-Sucuri-ID', 'X-Sucuri-Cached', 'Server: Sucuri/Cloudproxy'],
        'html_keywords': ['Sucuri WebSite Firewall - Blocked']
    },
    'akamai': {
        'headers': ['X-Akamai-Transformed', 'Akamai-Request-ID', 'Server: AkamaiGHost'],
        'cookies': ['akamai_origin_cookie']
    },
    'amazon_cloudfront': {
        'headers': ['X-Amz-Cf-Id', 'X-Cache', 'Via: 1.1 cloudfront'],
        'html_keywords': ['CloudFront Request ID']
    },
    'google_cloud_cdn': {
        'headers': ['Via: 1.1 google', 'X-Goog-Fed-Proxy', 'Server: Google Frontend']
    },
    'azure_frontdoor': {
        'headers': ['X-Azure-Ref', 'X-Cache: CONFIG_MISS', 'x-fdid', 'x-ms-request-id']
    },
    'f5_bigip_asm': {
        'headers': ['X-Forwarded-For: ', 'X-Cnection: close'],
        'html_keywords': ['The requested URL was rejected. Please consult with your administrator.']
    },
    'wordfence': {
        'headers': ['X-Wordfence-Cache', 'X-WF-Internal-Error'],
        'html_keywords': ['WordPress Security by Wordfence']
    },
    'mod_security': {
        'headers': ['Server: Mod_Security', 'Server: Secure Entry Point'],
        'html_keywords': ['Mod_Security', 'WAF Blocked', 'attack detected']
    },
    'barracuda_waf': {
        'headers': ['X-Barracuda-Appreciation-Id', 'X-Powered-By-Barracuda']
    },
    'dotdefender': {
        'headers': ['X-dotDefender-denied']
    },
    'reblaze': {
        'headers': ['X-Reblaze-ID']
    },
    'netscaler': {
        'headers': ['X-Citrix-NSC', 'X-NS-Request-ID', 'Set-Cookie: NSC_'],
        'cookies': ['NSC_']
    },
    'palo_alto_networks_waf': {
        'headers': ['x-paloalto-waf']
    },
    'imperva_incapsula': {
        'headers': ['X-Imperva', 'X-Protect', 'Set-Cookie: incap_ses_']
    },
    'distil_networks': {
        'headers': ['X-Distil-CS']
    },
    'radware_appwall': {
        'headers': ['X-WAF-Perf']
    },
    'openresty_waf': {
        'headers': ['Server: openresty']
    },
    'cdn77': {
        'headers': ['Server: CDN77-Turbo', 'X-CDN77-Cache']
    },
    'fastly': {
        'headers': ['X-Served-By', 'X-Cache: HIT', 'Fastly-Request-ID']
    },
    'maxcdn': {
        'headers': ['X-Cdn: MaxCDN']
    }
}


# --- Helper Functions ---

def is_valid_ip(ip_string):
    """Checks if a string is a valid IPv4 or IPv6 address."""
    try:
        ipaddress.ip_address(ip_string)
        return True
    except ValueError:
        return False

def get_dns_records(target_domain, record_type, verbose=False):
    """
    Retrieves DNS records for a given domain and record type.
    """
    records = []
    try:
        resolver = dns.resolver.Resolver()
        resolver.nameservers = PUBLIC_DNS_RESOLVERS
        answers = resolver.resolve(target_domain, record_type)
        for rdata in answers:
            record_str = str(rdata)
            records.append(record_str)
            if verbose:
                print(f"  [DNS-{record_type}] Found record: {record_str}")
    except dns.resolver.NoAnswer:
        if verbose: print(f"  [DNS-{record_type}] No {record_type} records found for {target_domain}.")
    except dns.resolver.NXDOMAIN:
        if verbose: print(f"  [DNS-{record_type}] Domain {target_domain} does not exist.")
    except Exception as e:
        if verbose: print(f"  [DNS-{record_type}] Error querying {record_type} records: {e}")
    return records

def get_crt_sh_ips(target_domain, verbose=False):
    """
    Queries crt.sh for historical IPs from Certificate Transparency logs.
    """
    ips = set()
    url = CRT_SH_URL.format(domain=target_domain)
    if verbose: print(f"  [CRT.sh] Querying: {url}")
    try:
        response = requests.get(url, timeout=10)
        response.raise_for_status() # Raise an exception for HTTP errors
        data = json.loads(response.text)

        for entry in data:
            if 'ip_addresses' in entry:
                for ip_addr in entry['ip_addresses'].split(', '):
                    if is_valid_ip(ip_addr.strip()):
                        ips.add(ip_addr.strip())
                        if verbose: print(f"  [CRT.sh] Found IP from entry: {ip_addr.strip()}")

    except requests.exceptions.RequestException as e:
        if verbose: print(f"  [CRT.sh] Error querying crt.sh: {e}")
    except json.JSONDecodeError as e:
        if verbose: print(f"  [CRT.sh] Error decoding crt.sh JSON response: {e}")
    except Exception as e:
        if verbose: print(f"  [CRT.sh] An unexpected error occurred with crt.sh: {e}")
    return list(ips)


def detect_github_pages(target_domain, verbose=False):
    """
    Detects if the target domain or its subdomains are hosted on GitHub Pages.
    """
    github_presence = False
    github_ips = set()

    if verbose: print(f"  [GitHub Detector] Checking for GitHub Pages via CNAME records for {target_domain}...")

    cname_records = get_dns_records(target_domain, 'CNAME', verbose)
    for cname in cname_records:
        if 'github.io' in cname:
            github_presence = True
            if verbose: print(f"  [GitHub Detector] Found CNAME pointing to GitHub Pages: {cname}")
            github_io_ips = get_dns_records(cname, 'A', verbose)
            github_ips.update(github_io_ips)

    return github_presence, list(github_ips)

def query_shodan_for_domain(target_domain, shodan_api_key, verbose=False):
    """
    Queries Shodan for historical IP information related to the target domain.
    """
    ips = set()
    if not shodan_api_key:
        if verbose: print("  [Shodan] Shodan API key not provided. Skipping Shodan query.")
        return []

    try:
        api = shodan.Shodan(shodan_api_key)
        if verbose: print(f"  [Shodan] Querying Shodan for domain: {target_domain}")

        results = api.search(f"hostname:{target_domain}")

        for result in results['matches']:
            ip_str = result['ip_str']
            if is_valid_ip(ip_str):
                ips.add(ip_str)
                if verbose:
                    print(f"  [Shodan] Found IP: {ip_str} (Port: {result.get('port')}, Org: {result.get('org')})")

    except shodan.APIError as e:
        if "No information available for that search query" in str(e):
            if verbose: print(f"  [Shodan] No results found for {target_domain} on Shodan.")
        elif "Invalid API key" in str(e):
            print(f"  [Shodan] Error: Invalid Shodan API key.")
        else:
            print(f"  [Shodan] Shodan API Error: {e}")
    except Exception as e:
        print(f"  [Shodan] An unexpected error occurred while querying Shodan: {e}")
    return list(ips)

def query_censys_for_domain(target_domain, censys_api_id, censys_api_secret, verbose=False):
    """
    Queries Censys for historical IP information related to the target domain.
    """
    ips = set()
    if not censys_api_id or not censys_api_secret:
        if verbose: print("  [Censys] Censys API ID or Secret not provided. Skipping Censys query.")
        return []

    try:
        c = censys.search.CensysSearch(api_id=censys_api_id, api_secret=censys_api_secret)

        if verbose: print(f"  [Censys] Querying Censys for hosts related to domain: {target_domain}")

        query = f"services.dns.names: {target_domain} OR p443.certificates.leaf.subject.common_name: {target_domain} OR p443.certificates.leaf.subject_alt_names: {target_domain}"

        for result in c.v2.hosts.search(query, fields=['ip'], per_page=50, pages=-1):
            ip_addr = result['ip']
            if is_valid_ip(ip_addr):
                ips.add(ip_addr)
                if verbose: print(f"  [Censys] Found IP: {ip_addr}")

    except censys.base.CensysException as e:
        if "Authentication failed" in str(e):
            print(f"  [Censys] Error: Censys Authentication failed. Check your API ID and Secret.")
        elif "No results found" in str(e) or "query returned no results" in str(e):
             if verbose: print(f"  [Censys] No results found for {target_domain} on Censys.")
        else:
            print(f"  [Censys] Censys API Error: {e}")
    except Exception as e:
        print(f"  [Censys] An unexpected error occurred while querying Censys: {e}")
    return list(ips)

# --- NEW: Email Header IP Extraction ---
def extract_ips_from_email_header(raw_email_headers, verbose=False):
    """
    Parses raw email headers (typically 'Received:' lines) to extract IP addresses.
    This is useful if you can obtain email headers from a target.
    """
    ips = set()
    ip_pattern = r'\b(?:[0-9]{1,3}\.){3}[0-9]{1,3}\b' # IPv4 pattern
    ip_pattern_v6 = r'\b(?:[0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}\b|\b(?:[0-9a-fA-F]{1,4}:){1,7}:[0-9a-fA-F]{1,4}\b' # Basic IPv6
    
    lines = raw_email_headers.splitlines()
    for line in lines:
        if line.lower().startswith('received:'):
            # Find IPv4 addresses
            found_ipv4s = re.findall(ip_pattern, line)
            for ip_addr in found_ipv4s:
                if is_valid_ip(ip_addr) and not ip_addr.startswith(('10.', '172.16.', '192.168.')): # Exclude private IPs
                    ips.add(ip_addr)
                    if verbose: print(f"  [Email Header] Found public IPv4 in '{line.strip()[:60]}...': {ip_addr}")
            
            # Find IPv6 addresses (more complex, simple pattern for now)
            found_ipv6s = re.findall(ip_pattern_v6, line)
            for ip_addr in found_ipv6s:
                if is_valid_ip(ip_addr):
                    ips.add(ip_addr)
                    if verbose: print(f"  [Email Header] Found public IPv6 in '{line.strip()[:60]}...': {ip_addr}")
    
    return list(ips)

# --- NEW: Reverse DNS Lookup ---
def perform_reverse_dns(ip_address, verbose=False):
    """
    Performs a reverse DNS lookup on an IP address to find associated hostnames.
    """
    hostnames = set()
    if not is_valid_ip(ip_address):
        if verbose: print(f"  [Reverse DNS] Skipping invalid IP for reverse lookup: {ip_address}")
        return []

    try:
        addr = dns.reversename.from_address(ip_address)
        resolver = dns.resolver.Resolver()
        resolver.nameservers = PUBLIC_DNS_RESOLVERS
        answers = resolver.resolve(addr, "PTR")
        for rdata in answers:
            hostname = str(rdata).rstrip('.') # Remove trailing dot
            hostnames.add(hostname)
            if verbose: print(f"  [Reverse DNS] PTR record for {ip_address}: {hostname}")
    except dns.resolver.NXDOMAIN:
        if verbose: print(f"  [Reverse DNS] No PTR record (NXDOMAIN) for {ip_address}.")
    except dns.resolver.NoAnswer:
        if verbose: print(f"  [Reverse DNS] No PTR answer for {ip_address}.")
    except Exception as e:
        if verbose: print(f"  [Reverse DNS] Error performing reverse DNS for {ip_address}: {e}")
    return list(hostnames)

# --- Functions for Active Mode and WAF Detection ---

def detect_waf(response_headers, response_body, verbose=False):
    """
    Analyzes HTTP response headers and body to detect WAFs.
    Returns a list of detected WAFs.
    """
    detected_wafs = []
    headers_lower = {k.lower(): v.lower() for k, v in response_headers.items()}
    response_body_lower = response_body.lower() if response_body else ""

    if verbose: print("  [WAF Detector] Analyzing headers and body for WAF signatures...")

    for waf_name, signatures in WAF_SIGNATURES.items():
        # Check headers
        if 'headers' in signatures:
            for header_sig in signatures['headers']:
                # Handle signatures that are just a key or key: value
                if ': ' in header_sig:
                    key, value = header_sig.split(': ', 1)
                    if key.lower() in headers_lower and value.lower() in headers_lower[key.lower()]:
                        if waf_name not in detected_wafs:
                            detected_wafs.append(waf_name)
                            if verbose: print(f"    [WAF] Detected {waf_name} via header: '{header_sig}'")
                            break # Found for this WAF, move to next WAF
                else: # Check for header key presence only
                    if header_sig.lower() in headers_lower:
                        if waf_name not in detected_wafs:
                            detected_wafs.append(waf_name)
                            if verbose: print(f"    [WAF] Detected {waf_name} via header key presence: '{header_sig}'")
                            break

        # Check cookies
        if 'cookies' in signatures:
            set_cookie_header = headers_lower.get('set-cookie', '')
            for cookie_sig in signatures['cookies']:
                if cookie_sig.lower() in set_cookie_header:
                    if waf_name not in detected_wafs:
                        detected_wafs.append(waf_name)
                        if verbose: print(f"    [WAF] Detected {waf_name} via cookie: '{cookie_sig}'")
                        break

        # Check HTML keywords in body (for blocking pages)
        if 'html_keywords' in signatures:
            for keyword in signatures['html_keywords']:
                if keyword.lower() in response_body_lower:
                    if waf_name not in detected_wafs:
                        detected_wafs.append(waf_name)
                        if verbose: print(f"    [WAF] Detected {waf_name} via HTML keyword: '{keyword[:40]}...'")
                        break
    return sorted(list(set(detected_wafs)))

def check_port(ip, port, timeout=1):
    """
    Checks if a specific port is open on an IP address.
    Returns True if open, False otherwise.
    """
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(timeout)
        result = sock.connect_ex((ip, port))
        sock.close()
        return result == 0
    except (socket.error, OverflowError):
        return False

def perform_active_scan(target_domain, potential_ips, verbose=False):
    """
    Performs active IP discovery and WAF detection by directly interacting with targets.
    """
    found_origin_ips = set()
    detected_wafs = set()
    print("\n--- Starting Active Scan ---")

    # If no potential IPs are given from passive, get the target domain's current public A/AAAA records
    if not potential_ips:
        if verbose: print("[Active] No potential IPs from passive scan. Resolving target domain's current DNS.")
        current_a_records = get_dns_records(target_domain, 'A', verbose)
        potential_ips.extend(current_a_records)
        current_aaaa_records = get_dns_records(target_domain, 'AAAA', verbose)
        potential_ips.extend(current_aaaa_records)

    if not potential_ips:
        print("[Active] No IPs to actively scan.")
        return [], []

    potential_ips = list(set(ip for ip in potential_ips if is_valid_ip(ip))) # Filter invalid IPs

    for ip in potential_ips:
        if not is_valid_ip(ip): continue # Double check for safety

        print(f"\n[*] Probing potential origin IP: {ip}")

        # 1. Port Scanning
        open_ports = []
        for port in COMMON_WEB_PORTS:
            if verbose: print(f"  [Active] Checking port {port} on {ip}...")
            if check_port(ip, port):
                open_ports.append(port)
                if verbose: print(f"    [SUCCESS] Port {port} is open.")
            else:
                if verbose: print(f"    [INFO] Port {port} is closed or filtered.")

        if open_ports:
            print(f"  [Active] Open web ports found on {ip}: {', '.join(map(str, open_ports))}")
        else:
            if verbose: print(f"  [Active] No common web ports found open on {ip}.")


        # 2. Direct HTTP/S Connection with Host Header
        headers = {
            'Host': target_domain,
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/100.0.4896.127 Safari/537.36 IP.X-Scanner/0.1',
            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
            'Accept-Language': 'en-US,en;q=0.5',
            'Accept-Encoding': 'gzip, deflate',
            'Connection': 'keep-alive'
        }
        schemes = ['https', 'http']

        for scheme in schemes:
            # Only try connecting if the corresponding port is found open OR if no ports were found at all
            # This balances speed vs. thoroughness if a port scan failed or was too quick
            if open_ports and ((scheme == 'https' and 443 not in open_ports) and (scheme == 'http' and 80 not in open_ports)):
                if verbose: print(f"  [Active] Skipping {scheme} to {ip} as common web ports were checked and not open.")
                continue

            url = f"{scheme}://{ip}/"
            try:
                if verbose: print(f"  [Active] Attempting direct {scheme} connection to {ip} with Host: {target_domain}")
                response = requests.get(url, headers=headers, timeout=7, allow_redirects=True, verify=False) # verify=False for self-signed/mismatched certs

                content_match = target_domain in response.text or \
                                f"https://{target_domain}" in response.text or \
                                f"http://{target_domain}" in response.text
                status_ok = 200 <= response.status_code < 300

                if (content_match and status_ok) or response.status_code == 200:
                    print(f"  [SUCCESS] Direct connection to {ip} ({scheme}) returned content for {target_domain} (Status: {response.status_code}).")
                    found_origin_ips.add(ip)
                else:
                    if verbose: print(f"  [INFO] Direct connection to {ip} ({scheme}) did not return expected content. Status: {response.status_code}")
                
                current_detected_wafs = detect_waf(response.headers, response.text, verbose)
                if current_detected_wafs:
                    print(f"    [WAF] Detected WAF(s) on {ip} ({scheme}): {', '.join(current_detected_wafs)}")
                    detected_wafs.update(current_detected_wafs)
                elif verbose:
                    print(f"    [WAF] No obvious WAF detected on {ip} ({scheme}).")

            except requests.exceptions.Timeout:
                if verbose: print(f"  [Active] Timeout connecting to {ip} ({scheme}).")
            except requests.exceptions.TooManyRedirects:
                if verbose: print(f"  [Active] Too many redirects from {ip} ({scheme}).")
            except requests.exceptions.ConnectionError:
                if verbose: print(f"  [Active] Connection error to {ip} ({scheme}).")
            except requests.exceptions.RequestException as e:
                if verbose: print(f"  [Active] An HTTP request error occurred to {ip} ({scheme}): {e}")
            except Exception as e:
                if verbose: print(f"  [Active] An unexpected error during active scan on {ip} ({scheme}): {e}")

    print("\n--- Active Scan Complete ---")
    return list(found_origin_ips), list(detected_wafs)

# --- Passive Scan Function (UPDATED) ---
def passive_scan(target, verbose=False, api_keys=None):
    """
    Performs passive IP collection techniques.
    """
    found_ips = set()
    found_hostnames = set() # To store hostnames found from reverse DNS

    print("\n--- Starting Passive Scan ---")

    print(f"\n[*] Collecting A records for {target}...")
    a_records = get_dns_records(target, 'A', verbose)
    found_ips.update(a_records)

    print(f"\n[*] Collecting AAAA records for {target}...")
    aaaa_records = get_dns_records(target, 'AAAA', verbose)
    found_ips.update(aaaa_records)

    print(f"\n[*] Querying Certificate Transparency logs (crt.sh) for {target}...")
    crt_sh_ips = get_crt_sh_ips(target, verbose)
    found_ips.update(crt_sh_ips)

    print(f"\n[*] Detecting GitHub Pages presence for {target}...")
    is_github_pages, github_page_ips = detect_github_pages(target, verbose)
    if is_github_pages:
        print(f"  [SUCCESS] {target} appears to be hosted on GitHub Pages!")
        if github_page_ips:
            print("  [INFO] IPs associated with GitHub Pages CNAME:")
            for ip in github_page_ips:
                print(f"    - {ip}")
                found_ips.add(ip)
    else:
        print(f"  [INFO] {target} does not appear to be directly hosted on GitHub Pages via CNAME.")

    print(f"\n[*] Querying Shodan for historical data related to {target}...")
    shodan_api_key = api_keys.get('shodan_api_key') if api_keys else None
    shodan_ips = query_shodan_for_domain(target, shodan_api_key, verbose)
    if shodan_ips:
        print(f"  [SUCCESS] Shodan found {len(shodan_ips)} potential IP(s).")
        for ip in shodan_ips:
            print(f"    - {ip}")
            found_ips.add(ip)
    else:
        print("  [INFO] Shodan did not return additional IPs or API key was missing/invalid.")

    print(f"\n[*] Querying Censys for historical data related to {target}...")
    censys_api_id = api_keys.get('censys_api_id') if api_keys else None
    censys_api_secret = api_keys.get('censys_api_secret') if api_keys else None
    censys_ips = query_censys_for_domain(target, censys_api_id, censys_api_secret, verbose)
    if censys_ips:
        print(f"  [SUCCESS] Censys found {len(censys_ips)} potential IP(s).")
        for ip in censys_ips:
            print(f"    - {ip}")
            found_ips.add(ip)
    else:
        print("  [INFO] Censys did not return additional IPs or API keys were missing/invalid.")

    # --- NEW Passive Steps ---

    print(f"\n[*] Performing Reverse DNS lookups on collected IPs...")
    # Perform reverse DNS on all current IPs found from passive sources
    current_found_ips_list = list(found_ips) # Convert to list to iterate
    for ip in current_found_ips_list:
        resolved_hostnames = perform_reverse_dns(ip, verbose)
        found_hostnames.update(resolved_hostnames)
        # We don't add these hostnames to found_ips, but they can be used for further enumeration

    if found_hostnames:
        print(f"  [INFO] Reverse DNS found {len(found_hostnames)} associated hostname(s):")
        for hostname in found_hostnames:
            print(f"    - {hostname}")
            # You could recursively call passive_scan on these hostnames, but be careful with depth/loops
            # For now, we'll just report them.

    # Email header analysis is typically a manual input or requires a specific mail server API.
    # For a command-line tool, it's harder to automate getting a raw email header without user input.
    # We've added the function, but it won't be called automatically without a source for headers.
    # Example usage (if you had a raw header string):
    # raw_header_example = """
    # Received: from mail.example.org (mail.example.org [198.51.100.1])
    #     by example.com (Postfix) with ESMTP id ABCDEF12345
    #     for <user@example.com>; Thu, 27 Jul 2025 10:00:00 +0000 (UTC)
    # Received: from [203.0.113.5] (localhost [127.0.0.1])
    #     by mail.example.org with ESMTPSA id GHIJKL67890
    #     for <user@example.com>; Thu, 27 Jul 2025 09:59:00 +0000 (UTC)
    # """
    # email_ips = extract_ips_from_email_header(raw_header_example, verbose)
    # if email_ips:
    #     print("\n[*] IPs from Email Headers (example, not automated):")
    #     found_ips.update(email_ips)


    print("\n--- Passive Scan Complete ---")
    return list(found_ips)


# --- Main function ---

def main():
    parser = argparse.ArgumentParser(
        description="IP.X - An origin IP finder behind WAF and CDN, with WAF detection capabilities.",
        formatter_class=argparse.RawTextHelpFormatter
    )

    parser.add_argument(
        "target",
        help="The target domain (e.g., example.com)."
    )
    parser.add_argument(
        "--active",
        action="store_true",
        help="Enable active mode (performs direct connections, port scans, etc.)."
    )
    parser.add_argument(
        "--passive",
        action="store_true",
        help="Enable passive mode (collects data from public sources like DNS history, CT logs)."
    )
    parser.add_argument(
        "--verbose",
        action="store_true",
        help="Enable verbose output for detailed information during the scan."
    )
    parser.add_argument(
        "--output",
        type=str,
        metavar="FILE",
        help="Save the scan results to the specified file."
    )
    parser.add_argument(
        "--api_keys",
        type=str,
        metavar="FILE",
        help="Path to a file containing API keys (e.g., Shodan, Censys) in JSON format.\n"
             "Example JSON content:\n"
             "{\n"
             "  \"shodan_api_key\": \"YOUR_SHODAN_API_KEY\",\n"
             "  \"censys_api_id\": \"YOUR_CENSYS_API_ID\",\n"
             "  \"censys_api_secret\": \"YOUR_CENSYS_API_SECRET\"\n"
             "}"
    )

    args = parser.parse_args()

    # Basic validation for active/passive mode
    if not args.active and not args.passive:
        print("Error: You must enable either --active or --passive mode (or both).")
        parser.print_help()
        sys.exit(1)

    # Load API keys if provided
    api_keys = {}
    if args.api_keys:
        try:
            with open(args.api_keys, 'r') as f:
                api_keys = json.load(f)
            if args.verbose:
                print(f"[*] Successfully loaded API keys from {args.api_keys}")
        except FileNotFoundError:
            print(f"Error: API keys file '{args.api_keys}' not found.")
            sys.exit(1)
        except json.JSONDecodeError:
            print(f"Error: Invalid JSON format in API keys file '{args.api_keys}'.")
            sys.exit(1)

    print(f"IP.X Scan Initiated for: {args.target}")
    print(f"Active Mode: {'Enabled' if args.active else 'Disabled'}")
    print(f"Passive Mode: {'Enabled' if args.passive else 'Disabled'}")
    print(f"Verbose Output: {'Enabled' if args.verbose else 'Disabled'}")
    print(f"Output File: {args.output if args.output else 'None'}")
    print(f"API Keys File: {args.api_keys if args.api_keys else 'None'}")

    all_found_ips = set()
    detected_wafs_overall = set()

    if args.passive:
        passive_ips = passive_scan(args.target, args.verbose, api_keys)
        all_found_ips.update(passive_ips)
        print(f"\nPassive scan found {len(passive_ips)} potential IP(s).")
        for ip in passive_ips:
            print(f"  - {ip}")

    if args.active:
        active_mode_found_ips, active_mode_detected_wafs = perform_active_scan(args.target, list(all_found_ips), args.verbose)
        all_found_ips.update(active_mode_found_ips)
        detected_wafs_overall.update(active_mode_detected_wafs)


    print("\n--- Scan Complete ---")
    if all_found_ips:
        print(f"\nTotal unique potential origin IP(s) found: {len(all_found_ips)}")
        for ip in sorted(list(all_found_ips)):
            print(f"  - {ip}")
    else:
        print("No potential origin IPs found.")

    if detected_wafs_overall:
        print(f"\nDetected WAF(s): {', '.join(sorted(list(detected_wafs_overall)))}")
    else:
        print("\nNo WAFs detected.")

    if args.output:
        try:
            with open(args.output, 'w') as f:
                f.write(f"IP.X Scan Results for: {args.target}\n")
                f.write(f"Active Mode: {'Enabled' if args.active else 'Disabled'}\n")
                f.write(f"Passive Mode: {'Enabled' if args.passive else 'Disabled'}\n")
                f.write(f"Verbose Output: {'Enabled' if args.verbose else 'Disabled'}\n")
                f.write("\n--- Potential Origin IPs ---\n")
                if all_found_ips:
                    for ip in sorted(list(all_found_ips)):
                        f.write(f"- {ip}\n")
                else:
                    f.write("No potential origin IPs found.\n")
                f.write("\n--- WAF Detection ---\n")
                if detected_wafs_overall:
                    f.write(f"Detected WAF(s): {', '.join(sorted(list(detected_wafs_overall)))}\n")
                else:
                    f.write("No WAFs detected.\n")
            print(f"\nResults saved to: {args.output}")
        except IOError as e:
            print(f"Error: Could not write to output file '{args.output}': {e}")


if __name__ == "__main__":
    main()
